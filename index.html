<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2563eb">
  <meta name="description" content="Gestion de location de photobooths">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“·</text></svg>">
  <title>Gestion Photobooth</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://apis.google.com/js/api.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Configuration Google Drive API
    const CLIENT_ID = '362970811261-iemtpn2m017af2ja4qsqjsjbkou59cje.apps.googleusercontent.com';
    const API_KEY = 'AIzaSyB7UaolNFtg__7qweEzNiwr40c4Gk13lQ8';
    const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
    const SCOPES = 'https://www.googleapis.com/auth/drive.appdata';

    function PhotoboothManager() {
      const [view, setView] = useState('calendar');
      const [currentDate, setCurrentDate] = useState(new Date());
      const [bornes, setBornes] = useState([]);
      const [forfaits, setForfaits] = useState([]);
      const [reservations, setReservations] = useState([]);
      const [rdvs, setRdvs] = useState([]);
      const [bobines, setBobines] = useState([]);
      const [stock, setStock] = useState([]);
      const [showAddModal, setShowAddModal] = useState(false);
      const [modalType, setModalType] = useState('');
      const [formData, setFormData] = useState({});
      const [editingItem, setEditingItem] = useState(null);
      const [confirmDelete, setConfirmDelete] = useState(null);
      const [showDateMenu, setShowDateMenu] = useState(null);
      const [showEventDetail, setShowEventDetail] = useState(null);
      const [notifications, setNotifications] = useState([]);
      const [showNotifications, setShowNotifications] = useState(false);
      const [notificationSettings, setNotificationSettings] = useState({
        telegram: { enabled: false, botToken: '', chatId: '' },
        email: { enabled: false, address: '' },
        weeklyReminder: true,
        dailyReminder: true,
        urgentAlerts: true,
        stockAlerts: true,
        maintenanceReminder: true
      });
      const [isGapiLoaded, setIsGapiLoaded] = useState(false);
      const [isSignedIn, setIsSignedIn] = useState(false);
      const [lastBackup, setLastBackup] = useState(null);
      const [backupStatus, setBackupStatus] = useState('idle');

      // Initialiser Google API
      useEffect(() => {
        const initGapi = () => {
          if (typeof gapi !== 'undefined') {
            gapi.load('client:auth2', () => {
              gapi.client.init({
                apiKey: API_KEY,
                clientId: CLIENT_ID,
                discoveryDocs: DISCOVERY_DOCS,
                scope: SCOPES
              }).then(() => {
                setIsGapiLoaded(true);
                const authInstance = gapi.auth2.getAuthInstance();
                setIsSignedIn(authInstance.isSignedIn.get());
                authInstance.isSignedIn.listen(setIsSignedIn);
                
                if (authInstance.isSignedIn.get()) {
                  loadFromDrive();
                }
              }).catch(err => {
                console.error('Erreur init Google API:', err);
              });
            });
          }
        };

        if (document.readyState === 'complete') {
          initGapi();
        } else {
          window.addEventListener('load', initGapi);
        }

        return () => window.removeEventListener('load', initGapi);
      }, []);

      // Connexion Google Drive
      const handleGoogleSignIn = () => {
        if (isGapiLoaded) {
          gapi.auth2.getAuthInstance().signIn();
        }
      };

      const handleGoogleSignOut = () => {
        if (isGapiLoaded) {
          gapi.auth2.getAuthInstance().signOut();
        }
      };

      // Sauvegarder sur Google Drive
      const saveToDrive = async () => {
        if (!isSignedIn) {
          alert('Connectez-vous Ã  Google Drive pour sauvegarder');
          return;
        }

        setBackupStatus('saving');
        
        const data = {
          bornes,
          forfaits,
          reservations,
          rdvs,
          bobines,
          stock,
          notifications,
          notificationSettings,
          lastBackup: new Date().toISOString()
        };

        try {
          // Chercher si un fichier backup existe
          const response = await gapi.client.drive.files.list({
            spaces: 'appDataFolder',
            fields: 'files(id, name)',
            q: "name='photobooth_backup.json'"
          });

          const boundary = '-------314159265358979323846';
          const delimiter = "\r\n--" + boundary + "\r\n";
          const close_delim = "\r\n--" + boundary + "--";

          const metadata = {
            name: 'photobooth_backup.json',
            mimeType: 'application/json'
          };

          const multipartRequestBody =
            delimiter +
            'Content-Type: application/json\r\n\r\n' +
            JSON.stringify(metadata) +
            delimiter +
            'Content-Type: application/json\r\n\r\n' +
            JSON.stringify(data) +
            close_delim;

          let fileId = null;
          if (response.result.files && response.result.files.length > 0) {
            fileId = response.result.files[0].id;
          }

          const request = gapi.client.request({
            path: fileId 
              ? `/upload/drive/v3/files/${fileId}`
              : '/upload/drive/v3/files',
            method: fileId ? 'PATCH' : 'POST',
            params: {
              uploadType: 'multipart',
              ...(fileId ? {} : { fields: 'id' })
            },
            headers: {
              'Content-Type': 'multipart/related; boundary="' + boundary + '"'
            },
            body: multipartRequestBody
          });

          await request;
          
          setLastBackup(new Date().toISOString());
          setBackupStatus('success');
          addNotification('info', 'ğŸ’¾ Sauvegarde rÃ©ussie', 'DonnÃ©es sauvegardÃ©es sur Google Drive', 'normal');
          
          setTimeout(() => setBackupStatus('idle'), 3000);
        } catch (error) {
          console.error('Erreur sauvegarde Drive:', error);
          setBackupStatus('error');
          addNotification('warning', 'âš ï¸ Erreur sauvegarde', 'Impossible de sauvegarder sur Drive', 'high');
          setTimeout(() => setBackupStatus('idle'), 3000);
        }
      };

      // Charger depuis Google Drive
      const loadFromDrive = async () => {
        if (!isSignedIn) return;

        try {
          const response = await gapi.client.drive.files.list({
            spaces: 'appDataFolder',
            fields: 'files(id, name)',
            q: "name='photobooth_backup.json'"
          });

          if (response.result.files && response.result.files.length > 0) {
            const fileId = response.result.files[0].id;
            const file = await gapi.client.drive.files.get({
              fileId: fileId,
              alt: 'media'
            });

            const data = file.result;
            setBornes(data.bornes || []);
            setForfaits(data.forfaits || []);
            setReservations(data.reservations || []);
            setRdvs(data.rdvs || []);
            setBobines(data.bobines || []);
            setStock(data.stock || []);
            setNotifications(data.notifications || []);
            setNotificationSettings(data.notificationSettings || notificationSettings);
            setLastBackup(data.lastBackup);
            
            addNotification('info', 'âœ… DonnÃ©es restaurÃ©es', 'DonnÃ©es chargÃ©es depuis Google Drive', 'normal');
          }
        } catch (error) {
          console.error('Erreur chargement Drive:', error);
          // Charger depuis localStorage en fallback
          loadFromLocalStorage();
        }
      };

      // Charger depuis localStorage
      const loadFromLocalStorage = () => {
        const savedBornes = localStorage.getItem('bornes');
        const savedForfaits = localStorage.getItem('forfaits');
        const savedReservations = localStorage.getItem('reservations');
        const savedRdvs = localStorage.getItem('rdvs');
        const savedBobines = localStorage.getItem('bobines');
        const savedStock = localStorage.getItem('stock');
        const savedNotifications = localStorage.getItem('notifications');
        const savedNotificationSettings = localStorage.getItem('notificationSettings');
        
        if (savedBornes) setBornes(JSON.parse(savedBornes));
        if (savedForfaits) setForfaits(JSON.parse(savedForfaits));
        if (savedReservations) setReservations(JSON.parse(savedReservations));
        if (savedRdvs) setRdvs(JSON.parse(savedRdvs));
        if (savedBobines) setBobines(JSON.parse(savedBobines));
        if (savedStock) setStock(JSON.parse(savedStock));
        if (savedNotifications) setNotifications(JSON.parse(savedNotifications));
        if (savedNotificationSettings) setNotificationSettings(JSON.parse(savedNotificationSettings));
      };

      // Charger les donnÃ©es au dÃ©marrage
      useEffect(() => {
        if (!isSignedIn) {
          loadFromLocalStorage();
        }
      }, []);

      // Sauvegarder dans localStorage
      useEffect(() => {
        localStorage.setItem('bornes', JSON.stringify(bornes));
        localStorage.setItem('forfaits', JSON.stringify(forfaits));
        localStorage.setItem('reservations', JSON.stringify(reservations));
        localStorage.setItem('rdvs', JSON.stringify(rdvs));
        localStorage.setItem('bobines', JSON.stringify(bobines));
        localStorage.setItem('stock', JSON.stringify(stock));
        localStorage.setItem('notifications', JSON.stringify(notifications));
        localStorage.setItem('notificationSettings', JSON.stringify(notificationSettings));
      }, [bornes, forfaits, reservations, rdvs, bobines, stock, notifications, notificationSettings]);

      // Sauvegarde automatique toutes les 24h
      useEffect(() => {
        if (!isSignedIn) return;

        const autoBackup = setInterval(() => {
          saveToDrive();
        }, 24 * 60 * 60 * 1000); // 24 heures

        return () => clearInterval(autoBackup);
      }, [isSignedIn, bornes, forfaits, reservations, rdvs, bobines, stock]);

      // Fonction pour trouver une bobine disponible
      const findAvailableBobine = (photosNeeded) => {
        const bobinesWithReservations = bobines.map(bobine => {
          const reserved = reservations
            .filter(r => r.bobineId === bobine.id && !r.bobineConsommee)
            .reduce((sum, r) => {
              const forfait = forfaits.find(f => f.id == r.forfaitId);
              return sum + (forfait?.nbPhotos || 0);
            }, 0);
          
          return {
            ...bobine,
            reserved,
            available: bobine.photosRestantes - reserved
          };
        });

        return bobinesWithReservations.find(b => b.available >= photosNeeded);
      };

      // DÃ©grever automatiquement les bobines
      useEffect(() => {
        const today = new Date().toISOString().split('T')[0];
        
        reservations.forEach(res => {
          if (res.dateFin < today && res.bobineId && !res.bobineConsommee) {
            const forfait = forfaits.find(f => f.id == res.forfaitId);
            if (forfait && forfait.nbPhotos) {
              setBobines(prevBobines => 
                prevBobines.map(b => 
                  b.id === res.bobineId 
                    ? { ...b, photosRestantes: Math.max(0, b.photosRestantes - forfait.nbPhotos) }
                    : b
                )
              );
              
              setReservations(prevRes => 
                prevRes.map(r => 
                  r.id === res.id 
                    ? { ...r, bobineConsommee: true }
                    : r
                )
              );

              addNotification('info', 'ğŸ“¦ Bobine dÃ©grevÃ©e', `Bobine dÃ©grevÃ©e de ${forfait.nbPhotos} photos pour ${res.clientNom}`, 'normal');
            }
          }
        });
      }, [reservations, forfaits, bobines]);

      const addNotification = (type, title, message, priority = 'normal') => {
        const newNotif = {
          id: Date.now(),
          type,
          title,
          message,
          priority,
          date: new Date().toISOString(),
          read: false
        };
        setNotifications(prev => [newNotif, ...prev]);
        
        if (notificationSettings.telegram.enabled && priority !== 'normal') {
          sendTelegramNotification(title, message);
        }
      };

      const sendTelegramNotification = async (title, message) => {
        if (!notificationSettings.telegram.botToken || !notificationSettings.telegram.chatId) return;
        
        try {
          const text = `ğŸ”” *${title}*\n\n${message}`;
          const url = `https://api.telegram.org/bot${notificationSettings.telegram.botToken}/sendMessage`;
          
          await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: notificationSettings.telegram.chatId,
              text: text,
              parse_mode: 'Markdown'
            })
          });
        } catch (error) {
          console.error('Erreur Telegram:', error);
        }
      };

      useEffect(() => {
        const checkNotifications = () => {
          const now = new Date();
          const today = now.toISOString().split('T')[0];
          const dayOfWeek = now.getDay();
          const hour = now.getHours();
          
          if (notificationSettings.weeklyReminder && dayOfWeek === 1 && hour === 8) {
            const thisWeek = reservations.filter(r => {
              const resDate = new Date(r.dateDebut);
              const weekStart = new Date(now);
              weekStart.setDate(now.getDate() - now.getDay() + 1);
              const weekEnd = new Date(weekStart);
              weekEnd.setDate(weekStart.getDate() + 7);
              return resDate >= weekStart && resDate < weekEnd;
            });
            
            if (thisWeek.length > 0) {
              addNotification('info', 'ğŸ“… RÃ©sumÃ© semaine', `${thisWeek.length} location(s) cette semaine`, 'high');
            }
          }
          
          if (notificationSettings.dailyReminder && hour === 8) {
            const todayEvents = reservations.filter(r => r.dateDebut === today);
            const todayRdvs = rdvs.filter(r => r.date === today);
            
            if (todayEvents.length > 0 || todayRdvs.length > 0) {
              addNotification('warning', 'âš ï¸ Aujourd\'hui', `${todayEvents.length} location(s) et ${todayRdvs.length} RDV`, 'high');
            }
          }
          
          reservations.forEach(res => {
            const resDate = new Date(res.dateDebut);
            const diff = (resDate - now) / (1000 * 60 * 60);
            
            if (diff > 46 && diff < 50) {
              addNotification('warning', 'â° Dans 48h', `Location ${res.clientNom} le ${res.dateDebut}`, 'high');
            }
            
            if (diff > 22 && diff < 26) {
              addNotification('urgent', 'ğŸš¨ Demain', `Location ${res.clientNom} demain Ã  ${res.heureDebut}`, 'urgent');
            }
          });
          
          const urgentThemes = reservations.filter(res => {
            if (res.themeRealisÃ© || !res.theme) return false;
            const daysUntil = Math.ceil((new Date(res.dateDebut) - now) / (1000 * 60 * 60 * 24));
            return daysUntil <= 2 && daysUntil >= 0;
          });
          
          if (urgentThemes.length > 0 && notificationSettings.urgentAlerts) {
            addNotification('warning', 'ğŸ¨ ThÃ¨mes urgents', `${urgentThemes.length} thÃ¨me(s) Ã  prÃ©parer`, 'high');
          }

          const lowStock = stock.filter(s => s.quantite <= s.seuilAlerte);
          if (lowStock.length > 0 && notificationSettings.stockAlerts) {
            addNotification('warning', 'ğŸ“¦ Stock faible', `${lowStock.length} article(s) faible`, 'high');
          }

          const lowBobines = bobines.filter(b => b.photosRestantes < 100);
          if (lowBobines.length > 0 && notificationSettings.stockAlerts) {
            addNotification('warning', 'ğŸï¸ Bobines faibles', `${lowBobines.length} bobine(s) < 100 photos`, 'high');
          }
        };
        
        const interval = setInterval(checkNotifications, 60 * 60 * 1000);
        checkNotifications();
        
        return () => clearInterval(interval);
      }, [reservations, rdvs, stock, bobines, notificationSettings]);

      const markAsRead = (id) => {
        setNotifications(prev => prev.map(n => n.id === id ? { ...n, read: true } : n));
      };

      const deleteNotification = (id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
      };

      const unreadCount = notifications.filter(n => !n.read).length;

      const openReservationModal = (prefilledDate = null) => {
        setModalType('reservation');
        setEditingItem(null);
        const dateStr = prefilledDate ? prefilledDate.toISOString().split('T')[0] : '';
        setFormData({
          type: 'reservation',
          borneId: '',
          forfaitId: '',
          clientNom: '',
          clientTel: '',
          dateDebut: dateStr,
          heureDebut: '10:00',
          dateFin: dateStr,
          heureFin: '23:00',
          lieuDepot: '',
          lieuRetour: '',
          theme: '',
          themeRealisÃ©: false,
          bobineId: null,
          bobineConsommee: false
        });
        setShowAddModal(true);
        setShowDateMenu(null);
      };

      const openRdvModal = (prefilledDate = null) => {
        setModalType('rdv');
        setEditingItem(null);
        const dateStr = prefilledDate ? prefilledDate.toISOString().split('T')[0] : '';
        setFormData({
          type: 'rdv',
          date: dateStr,
          heure: '10:00',
          clientNom: '',
          clientTel: '',
          description: ''
        });
        setShowAddModal(true);
        setShowDateMenu(null);
      };

      const handleSave = () => {
        if (modalType === 'borne') {
          if (editingItem) {
            setBornes(bornes.map(b => b.id === editingItem.id ? { ...formData, id: editingItem.id } : b));
          } else {
            setBornes([...bornes, { ...formData, id: Date.now() }]);
          }
        } else if (modalType === 'forfait') {
          if (editingItem) {
            setForfaits(forfaits.map(f => f.id === editingItem.id ? { ...formData, id: editingItem.id } : f));
          } else {
            setForfaits([...forfaits, { ...formData, id: Date.now() }]);
          }
        } else if (modalType === 'reservation') {
          const forfait = forfaits.find(f => f.id == formData.forfaitId);
          let finalData = { ...formData };
          
          if (forfait && forfait.nbPhotos && !editingItem) {
            const bobineDisponible = findAvailableBobine(forfait.nbPhotos);
            if (bobineDisponible) {
              finalData.bobineId = bobineDisponible.id;
              addNotification('info', 'âœ… Bobine attribuÃ©e', `Bobine #${bobineDisponible.numero} (${bobineDisponible.available} dispo)`, 'normal');
            } else {
              addNotification('warning', 'âš ï¸ Pas de bobine', `Aucune bobine pour ${forfait.nbPhotos} photos`, 'high');
            }
          }
          
          if (editingItem) {
            setReservations(reservations.map(r => r.id === editingItem.id ? { ...finalData, id: editingItem.id } : r));
          } else {
            setReservations([...reservations, { ...finalData, id: Date.now() }]);
          }
        } else if (modalType === 'rdv') {
          if (editingItem) {
            setRdvs(rdvs.map(r => r.id === editingItem.id ? { ...formData, id: editingItem.id } : r));
          } else {
            setRdvs([...rdvs, { ...formData, id: Date.now() }]);
          }
        } else if (modalType === 'stock') {
          if (editingItem) {
            setStock(stock.map(s => s.id === editingItem.id ? { ...formData, id: editingItem.id } : s));
          } else {
            setStock([...stock, { ...formData, id: Date.now() }]);
          }
        } else if (modalType === 'bobine') {
          if (editingItem) {
            setBobines(bobines.map(b => b.id === editingItem.id ? { ...formData, id: editingItem.id } : b));
          } else {
            const newBobine = {
              ...formData,
              id: Date.now(),
              photosRestantes: formData.capacite,
              dateAjout: new Date().toISOString().split('T')[0]
            };
            setBobines([...bobines, newBobine]);
            addNotification('info', 'ğŸï¸ Bobine ajoutÃ©e', `Bobine #${formData.numero} (${formData.capacite} photos)`, 'normal');
          }
        }
        setShowAddModal(false);
      };

      const handleDelete = (type, id) => {
        if (type === 'borne') setBornes(bornes.filter(b => b.id !== id));
        else if (type === 'forfait') setForfaits(forfaits.filter(f => f.id !== id));
        else if (type === 'reservation') setReservations(reservations.filter(r => r.id !== id));
        else if (type === 'rdv') setRdvs(rdvs.filter(r => r.id !== id));
        else if (type === 'stock') setStock(stock.filter(s => s.id !== id));
        else if (type === 'bobine') setBobines(bobines.filter(b => b.id !== id));
        setConfirmDelete(null);
      };

      const getDaysInMonth = (date) => {
        const year = date.getFullYear();
        const month = date.getMonth();
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        const startingDayOfWeek = firstDay.getDay();
        return { daysInMonth, startingDayOfWeek, year, month };
      };

      const getEventsForDay = (day) => {
        const dateStr = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const dayReservations = reservations.filter(r => r.dateDebut === dateStr || r.dateFin === dateStr);
        const dayRdvs = rdvs.filter(r => r.date === dateStr);
        return [...dayReservations, ...dayRdvs];
      };

      const toggleThemeRealise = (resId) => {
        setReservations(reservations.map(r => r.id === resId ? { ...r, themeRealisÃ©: !r.themeRealisÃ© } : r));
      };

      const themesAPreparer = reservations.filter(r => r.theme && !r.themeRealisÃ©);

      const renderCalendar = () => {
        const { daysInMonth, startingDayOfWeek } = getDaysInMonth(currentDate);
        const days = [];
        
        for (let i = 0; i < startingDayOfWeek; i++) {
          days.push(<div key={`empty-${i}`} className="h-24 bg-gray-50"></div>);
        }
        
        for (let day = 1; day <= daysInMonth; day++) {
          const events = getEventsForDay(day);
          const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
          
          days.push(
            <div
              key={day}
              className="h-24 border border-gray-200 p-1 bg-white hover:bg-gray-50 cursor-pointer relative"
              onClick={(e) => {
                e.stopPropagation();
                if (e.target === e.currentTarget || e.target.classList.contains('font-bold')) {
                  const rect = e.currentTarget.getBoundingClientRect();
                  const x = rect.left + rect.width / 2;
                  const y = rect.top + rect.height / 2;
                  setShowDateMenu({ day, x, y, date });
                }
              }}
            >
              <div className="font-bold text-sm">{day}</div>
              <div className="text-xs space-y-1 overflow-hidden">
                {events.slice(0, 2).map((event, idx) => (
                  <div
                    key={idx}
                    onClick={(e) => {
                      e.stopPropagation();
                      setShowEventDetail(event);
                    }}
                    className={`px-1 py-0.5 rounded text-white truncate cursor-pointer hover:opacity-80 ${
                      event.type === 'reservation' ? 'bg-blue-500' : 'bg-green-500'
                    }`}
                  >
                    {event.type === 'reservation' ? 'ğŸ“·' : 'ğŸ“…'} {event.clientNom || event.description}
                  </div>
                ))}
                {events.length > 2 && (
                  <div className="text-xs text-gray-500">+{events.length - 2}</div>
                )}
              </div>
            </div>
          );
        }
        
        return days;
      };

      return (
        <div className="min-h-screen bg-gray-100">
          <div className="sticky top-0 z-30 bg-white shadow-md">
            <div className="max-w-7xl mx-auto px-4">
              <div className="flex justify-between items-center py-3">
                <h1 className="text-xl font-bold text-blue-600">ğŸ“· Gestion Photobooth</h1>
                
                {/* Boutons Google Drive */}
                <div className="flex gap-2 items-center">
                  {isSignedIn ? (
                    <>
                      <button
                        onClick={saveToDrive}
                        disabled={backupStatus === 'saving'}
                        className={`px-3 py-1 text-sm rounded ${
                          backupStatus === 'saving' ? 'bg-gray-300' :
                          backupStatus === 'success' ? 'bg-green-500 text-white' :
                          backupStatus === 'error' ? 'bg-red-500 text-white' :
                          'bg-blue-500 text-white hover:bg-blue-600'
                        }`}
                      >
                        {backupStatus === 'saving' ? 'ğŸ’¾ Sauvegarde...' :
                         backupStatus === 'success' ? 'âœ… SauvegardÃ©' :
                         backupStatus === 'error' ? 'âŒ Erreur' :
                         'ğŸ’¾ Sauvegarder'}
                      </button>
                      <button
                        onClick={handleGoogleSignOut}
                        className="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600"
                      >
                        âï¸ DÃ©connexion
                      </button>
                    </>
                  ) : (
                    <button
                      onClick={handleGoogleSignIn}
                      className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
                    >
                      ğŸ” Connexion Drive
                    </button>
                  )}
                </div>
              </div>

              {lastBackup && (
                <div className="text-xs text-gray-500 pb-2">
                  DerniÃ¨re sauvegarde : {new Date(lastBackup).toLocaleString('fr-FR')}
                </div>
              )}

              <nav className="flex gap-2 border-b border-gray-200 pb-2">
                <button
                  onClick={() => { setView('calendar'); setShowNotifications(false); }}
                  className={`px-3 py-2 rounded-t-lg transition-colors text-sm ${
                    view === 'calendar' ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'
                  }`}
                >
                  ğŸ“… Calendrier
                </button>
                <button
                  onClick={() => { setView('admin'); setShowNotifications(false); }}
                  className={`px-3 py-2 rounded-t-lg transition-colors text-sm ${
                    view === 'admin' ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'
                  }`}
                >
                  âš™ï¸ Admin
                </button>
                <button
                  onClick={() => setShowNotifications(!showNotifications)}
                  className="ml-auto px-3 py-2 rounded-t-lg bg-gray-200 hover:bg-gray-300 relative text-sm"
                >
                  ğŸ”” Notifications
                  {unreadCount > 0 && (
                    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold">
                      {unreadCount}
                    </span>
                  )}
                </button>
              </nav>
            </div>
          </div>

          <div className="max-w-7xl mx-auto p-4">
            {/* Le reste de l'application reste identique */}
            <div className="text-center py-20">
              <h2 className="text-2xl font-bold mb-4">Application Photobooth PWA</h2>
              <p className="text-gray-600 mb-4">
                {isSignedIn 
                  ? 'âœ… ConnectÃ© Ã  Google Drive - Sauvegarde automatique activÃ©e' 
                  : 'âš ï¸ Connectez-vous Ã  Google Drive pour sauvegarder vos donnÃ©es'}
              </p>
              <p className="text-sm text-gray-500">
                Interface complÃ¨te du calendrier Ã  intÃ©grer ici
              </p>
            </div>
          </div>
        </div>
      );
    }

    // Enregistrer le Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then(reg => console.log('Service Worker enregistrÃ©'))
          .catch(err => console.error('Erreur SW:', err));
      });
    }

    // GÃ©rer l'installation PWA
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      
      // Afficher un bouton d'installation personnalisÃ©
      const installBtn = document.createElement('button');
      installBtn.textContent = 'ğŸ“± Installer l\'application';
      installBtn.className = 'fixed bottom-4 right-4 px-6 py-3 bg-blue-500 text-white rounded-lg shadow-lg hover:bg-blue-600 z-50';
      installBtn.onclick = async () => {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        if (outcome === 'accepted') {
          installBtn.remove();
        }
        deferredPrompt = null;
      };
      document.body.appendChild(installBtn);
    });

    ReactDOM.render(<PhotoboothManager />, document.getElementById('root'));
  </script>
</body>
</html>
